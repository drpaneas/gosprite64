// Command audiogen generates an audio_embed.go file with embedded audio files for gosprite64.
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// Parse command line flags
	var outputDir string
	flag.StringVar(&outputDir, "dir", ".", "Directory where the audio_embed.go file will be created")
	flag.BoolVar(&verbose, "verbose", false, "Enable verbose output")
	flag.Parse()

	// Find all audio files (music*.raw and sfx_*.raw)
	audioFiles, err := findAudioFiles(outputDir)
	if err != nil {
		fmt.Printf("Error searching for audio files: %v\n", err)
		os.Exit(1)
	}

	// Filter out invalid audio files and convert to relative paths
	var audioRelPaths []string
	for _, file := range audioFiles {
		relPath, err := filepath.Rel(outputDir, file)
		if err != nil {
			fmt.Printf("Error getting relative path for %s: %v\n", file, err)
			continue
		}
		if verbose {
			fmt.Printf("Including audio file: %s\n", relPath)
		}
		audioRelPaths = append(audioRelPaths, relPath)
	}

	// If no audio files were found, exit
	if len(audioRelPaths) == 0 {
		fmt.Printf("No audio files (*.raw) found in %s\n", outputDir)

		// Check if an audio_embed.go file exists and remove it if it does
		embedGoPath := filepath.Join(outputDir, "audio_embed.go")
		if fileExists(embedGoPath) {
			err := os.Remove(embedGoPath)
			if err != nil {
				fmt.Printf("Warning: Failed to remove existing audio_embed.go file: %v\n", err)
			} else if verbose {
				fmt.Printf("Removed existing audio_embed.go file as no audio files were found\n")
			}
		}
		return
	}

	// Generate the embed.go file
	err = generateEmbedFile(outputDir, audioRelPaths)
	if err != nil {
		fmt.Printf("Error generating audio_embed.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated audio_embed.go with %d audio files\n", len(audioRelPaths))
}

// findAudioFiles searches for audio files in the given directory
func findAudioFiles(dir string) ([]string, error) {
	var files []string

	// Find music*.raw files
	musicFiles, err := filepath.Glob(filepath.Join(dir, "music*.raw"))
	if err != nil {
		return nil, fmt.Errorf("error searching for music*.raw files: %w", err)
	}
	files = append(files, musicFiles...)

	// Find sfx_*.raw files
	sfxFiles, err := filepath.Glob(filepath.Join(dir, "sfx_*.raw"))
	if err != nil {
		return nil, fmt.Errorf("error searching for sfx_*.raw files: %w", err)
	}
	files = append(files, sfxFiles...)

	return files, nil
}

// generateEmbedFile creates the audio_embed.go file with the embedded audio files
func generateEmbedFile(dir string, audioFiles []string) error {
	if len(audioFiles) == 0 {
		return nil
	}

	// Create the output file
	outputFile := filepath.Join(dir, "audio_embed.go")
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	// Get the package name from the current directory
	pkgName := "main"
	if dir != "." {
		pkgName = filepath.Base(dir)
	}

	// Generate the file content
	content := fmt.Sprintf(`// Code generated by audiogen; DO NOT EDIT.

package %s

import (
	"embed"

	"github.com/drpaneas/gosprite64"
)

//go:embed %s
var audioFS embed.FS

func init() {
	// Initialize the audio filesystem with embedded audio files
	gosprite64.SetAudioFS(audioFS)
}
`, pkgName, strings.Join(audioFiles, " "))

	// Write the content to the file
	_, err = f.WriteString(content)
	if err != nil {
		return fmt.Errorf("failed to write to output file: %w", err)
	}

	if verbose {
		fmt.Printf("Generated %s with %d audio files\n", outputFile, len(audioFiles))
	}
	return nil
}

// fileExists checks if a file exists and is not a directory
func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

// Global variable for verbose output
var verbose bool
